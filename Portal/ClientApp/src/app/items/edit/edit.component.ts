import * as $ from 'jquery';
import { Observable, timer, of } from 'rxjs';
import { ActivatedRoute } from '@angular/router';
import { switchMap, map } from 'rxjs/operators';
import { ItemDto } from '../../_autogenerated/itemDto';
import { PartDto } from '../../_autogenerated/partDto';
import { DxDateBoxComponent } from 'devextreme-angular';
import { ItemService } from '../../services/item.service';
import { addDays } from '../../helpers/forms/date-helper';
import { PatchHelper } from '../../helpers/forms/patch-helper';
import { CategoryDto } from '../../_autogenerated/categoryDto';
import { ItemBindingModelExtended } from '../../models/extensions';
import { NavigationService } from '../../services/navgation.service';
import { FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms';
import { Component, OnInit, ViewChildren, AfterViewInit, QueryList } from '@angular/core';
import { ErrorStateMatcherExtension } from '../../helpers/forms/error-state-matcher-extension';

@Component({
  templateUrl: './edit.component.html',
  styleUrls: ['./edit.component.scss']
})
export class EditComponent implements OnInit, AfterViewInit {

  public item: ItemDto;
  public form: FormGroup;
  public parts: PartDto[];
  public selectedOption: string;
  public categories: CategoryDto[];
  public item$: Observable<ItemDto>;
  public matcher = new ErrorStateMatcherExtension();
  public options = [{ text: 'Option One', id: 0 }, { text: 'Option Two', id: 1 }, { text: 'Option Three', id: 2 }];

  @ViewChildren(DxDateBoxComponent) dateBox: QueryList<DxDateBoxComponent>

  constructor(
    private itemService: ItemService,
    private formBuilder: FormBuilder,
    private activatedRoute: ActivatedRoute,
    private navigationService: NavigationService
  ) { }

  ngOnInit() {
    this.item = this.activatedRoute.snapshot.data['item'] || new ItemBindingModelExtended();
    this.itemService.getParts().subscribe(parts => this.parts = parts);
    this.itemService.getCategories().subscribe(cateogries => this.categories = cateogries);
    this.initForm();
  }

  ngAfterViewInit(): void {
    this.fromValidationCallback({ existing: this.item.from as any });
    this.toValidationCallback({ existing: this.item.to as any });
    $('.dx-datebox .dx-texteditor-input').attr('readonly', (true as any));
  }

  private initForm = () => {
    this.form = this.formBuilder.group({
      to: [this.item.to],
      from: [this.item.from],
      parts: [this.item.parts],
      isActive: [this.item.isActive],
      categoryId: [this.item.categoryId],
      optionId: [this.item.optionId],
      name: [this.item.name, [Validators.required, this.hasNmbrSevenInStringCustomValidator]],
      email: [this.item.email, [Validators.required, Validators.email], this.isEmailUniqueAsyncValidator.bind(this)],
    });
    const optionIdCtrl = this.form.get('optionId');
    optionIdCtrl.valueChanges.subscribe(index => this.selectedOption = this.options[index].text);
    optionIdCtrl.updateValueAndValidity();
  }

  public submit = () => {
    if (this.form.valid) {
      if (this.item.id !== 0) {
        const model = PatchHelper.generatePatchObjects(this.form);
        this.itemService.updateItem(model, this.item.id).subscribe(response => this.back());
      } else {
        const model = this.form.getRawValue();
        this.itemService.createItem(model).subscribe(response => this.back());
      }
    }
    else {
      for (let ctrl in this.form.controls) {
        this.form.controls[ctrl].markAsDirty();
      }
    }
  }

  private dateValidationCallback = (e: { value?: string, existing: string }, type: DatePickerType) => {
    const selectedDate = new Date(e.existing || e.value);
    let fromDxDb = (this.dateBox.first as DxDateBoxComponent).instance;
    let toDxDb = (this.dateBox.last as DxDateBoxComponent).instance;
    let fromValue = new Date(fromDxDb.option('value'));
    let toValue = new Date(toDxDb.option('value'));

    if (type === DatePickerType.From) {
      toDxDb.option('disabledDates', (dt: { date: Date }) => dt.date <= selectedDate);
      if (toValue < selectedDate) {
        toDxDb.option('value', addDays(selectedDate, 1));
      }
    } else {
      fromDxDb.option('disabledDates', (dt: { date: Date }) => dt.date >= selectedDate);
      if (fromValue > selectedDate) {
        fromDxDb.option('value', addDays(selectedDate, -1));
      }
    }
    return true;
  }


  public fromValidationCallback = (e: { value?: string, existing: string }) =>
    this.dateValidationCallback(e, DatePickerType.From);

  public toValidationCallback = (e: { value?: string, existing: string }) =>
    this.dateValidationCallback(e, DatePickerType.To)

  public onOpened = (e) => $('.dx-button-today').remove();

  public isEmailUniqueAsyncValidator(email: FormControl) {
    if (email.dirty && email.value) {
      return timer(500).pipe(
        switchMap(() => {
          return this.itemService.validateEmail(email.value, this.item.id)
            .pipe(map(res => !!res ? { 'emailExists': true } : null))
        })
      )
    } else {
      return of(null);
    }
  }

  private hasNmbrSevenInStringCustomValidator = (ctrl: FormControl) => {
    const isValid = ctrl.value && (ctrl.value as string).indexOf('7') !== -1;
    return isValid ? null : { 'invalidName': true };
  }

  public back = () => this.navigationService.GoToItemOVerview();
}

enum DatePickerType {
  From,
  To
}